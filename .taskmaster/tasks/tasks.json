{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Unify Suggester to Always Insert Shortcodes",
        "description": "Modify the emoji suggester to consistently insert emoji shortcodes (e.g., `:smile:`) into the editor, regardless of whether the user is in Source Mode or Live Preview. This standardizes the data format in the Markdown files and is the first step in the new architecture.",
        "details": "Locate the `onChooseSuggestion` method within the `EditorSuggest` implementation for the emoji picker. Remove any conditional logic that checks the editor mode (e.g., `isSourceMode`, `isStrictSourceMode`). The logic should be updated to always take the selected emoji object from `emoji-mart` and insert its `id` field formatted as a shortcode, like `:${emoji.id}:`.",
        "testStrategy": "Trigger the emoji suggester in both Source Mode and Live Preview. Select an emoji in each mode. Verify that the text inserted into the editor is always the shortcode (e.g., `:rocket:`) and not the native emoji glyph (üöÄ).",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement and Fix Markdown Post-Processor",
        "description": "Implement and debug the `MarkdownPostProcessor` to find and replace emoji shortcodes with their corresponding native emoji glyphs during rendering in Live Preview and Reading modes.",
        "details": "In the main plugin class, use `this.registerMarkdownPostProcessor((element, context) => { ... });`. The processor should traverse the child nodes of the provided `element`. For each text node, use the regex `/:([a-z0-9_+-]+):/gi` to find all shortcode matches. For each match, replace the text node with multiple nodes: a text node for the text before the match, a `<span>` or `Text` node containing the resolved emoji glyph, and a text node for the text after. Use `emoji-mart`'s search index to resolve the shortcode `id` to a native emoji character.",
        "testStrategy": "Create a Markdown note with several valid shortcodes (e.g., `:smile:`, `:cat:`, `:thumbs_up:`). Switch to Live Preview and then Reading mode. Verify that all shortcodes are rendered as their corresponding emoji glyphs. Check the developer console for errors.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Register the Markdown Post-Processor and Basic Scaffolding",
            "description": "Set up the fundamental structure for the emoji post-processor by registering it within the main plugin's `onload` method. This initial step ensures the processor is active and ready for further implementation.",
            "dependencies": [],
            "details": "In the main plugin class's `onload` method, add the call `this.registerMarkdownPostProcessor((element, context) => { ... });`. The callback function should initially be empty or contain a `console.log('Post-processor triggered')` to verify it's being called correctly during Markdown rendering in Live Preview and Reading modes.",
            "status": "done",
            "testStrategy": "Open a Markdown file in Obsidian. Open the developer console. Verify that the log message 'Post-processor triggered' appears when the view renders or changes, confirming the processor is correctly registered."
          },
          {
            "id": 2,
            "title": "Implement DOM Traversal to Find All Text Nodes",
            "description": "Implement the logic within the post-processor to traverse the DOM of the rendered `element` and identify all `Text` nodes that may contain emoji shortcodes.",
            "dependencies": [
              "2.1"
            ],
            "details": "Inside the post-processor callback, implement a DOM traversal function. A `TreeWalker` is recommended for efficiency: `const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);`. Iterate through the walker (`while (walker.nextNode())`) to get all text nodes. For now, log the `textContent` of each found text node to the console to confirm the traversal is working.",
            "status": "done",
            "testStrategy": "Create a markdown note with various elements like headings, paragraphs, and list items. Check the developer console to confirm that the `textContent` of all text within these elements is being logged by the post-processor."
          },
          {
            "id": 3,
            "title": "Find Shortcodes with Regex and Resolve Emoji Data",
            "description": "For each identified text node, use the specified regex to find all emoji shortcode matches. For each valid match, use the `emoji-mart` search index to look up the corresponding emoji data.",
            "dependencies": [
              "2.2"
            ],
            "details": "Within the text node processing loop, use the regex `/:([a-z0-9_+-]+):/gi` on the node's `textContent`. Use `String.prototype.matchAll()` to get an iterator of all matches. For each match, extract the shortcode name from the first capture group. Use this name to query the pre-loaded `emoji-mart` data index to resolve it to an emoji object. If an emoji object is found, log it to the console.",
            "status": "done",
            "testStrategy": "Create a markdown note with valid shortcodes (e.g., `:smile:`, `:rocket:`) and invalid/plain text (e.g., `:not_an_emoji:`, `10:30`). Verify that the console logs the correct emoji data objects only for the valid shortcodes."
          },
          {
            "id": 4,
            "title": "Implement DOM Replacement for Found Shortcodes",
            "description": "Implement the core logic to replace a text node containing shortcodes with a new set of nodes representing the text and the resolved emoji glyphs.",
            "dependencies": [
              "2.3"
            ],
            "details": "This is a complex operation. For each text node containing matches, create a `DocumentFragment`. Iterate through the regex matches. For the text between the last match and the current one, create and append a `Text` node. For the match itself, create and append a `<span>` or `Text` node containing the resolved native emoji glyph. After the loop, append any remaining text after the last match. Finally, use `textNode.replaceWith(fragment)` to replace the original text node with the newly constructed content in a single DOM operation.",
            "status": "done",
            "testStrategy": "Create a note with text like `Hello :world:!` and `Test :cat: and :dog: emojis.`. Switch to Live Preview and Reading mode. Verify the output is rendered correctly as 'Hello üåé!' and 'Test üêà and üêï emojis.'. Check the DOM inspector to confirm the original text nodes have been replaced."
          },
          {
            "id": 5,
            "title": "Debug and Refine Processor for Edge Cases",
            "description": "Test the post-processor thoroughly in both Live Preview and Reading modes, fixing any bugs related to cursor position, selection, or rendering artifacts that arise from the DOM manipulation.",
            "dependencies": [
              "2.4"
            ],
            "details": "The DOM manipulation in Live Preview can be sensitive. Systematically test various scenarios: shortcodes at the beginning/end of a line, adjacent shortcodes (`:one::two:`), shortcodes within links or other markdown syntax. Pay close attention to the editor's behavior when clicking or typing near the replaced emojis. Ensure that the replacement logic does not cause excessive re-renders or performance degradation on large documents. Add checks to ensure the text node's parent exists before attempting replacement.",
            "status": "done",
            "testStrategy": "Create a comprehensive test file with shortcodes in various contexts: inside lists, blockquotes, headings, and next to other markdown syntax like bold or italics. Edit the text around the rendered emojis in Live Preview to check for stability. Verify there are no errors in the developer console during these operations."
          }
        ]
      },
      {
        "id": 3,
        "title": "Refine Post-Processor to Respect Code and Math Boundaries",
        "description": "Enhance the Markdown post-processor to prevent it from replacing shortcodes that appear inside of HTML `<code>` tags, `<pre>` blocks (for code blocks), and math blocks.",
        "details": "Within the `MarkdownPostProcessor`'s DOM traversal logic, before attempting to replace a shortcode in a text node, check its ancestry. Use `textNode.parentElement.closest('pre, code, .math, .cm-inline-code')` to determine if the node is within a boundary that should be ignored. If this check returns a non-null element, skip the replacement logic for that text node.",
        "testStrategy": "Create a test note with shortcodes in various locations: a normal paragraph, inside `inline code`, within a fenced ```code block```, and inside a `$$math block$$`. Confirm that only the shortcode in the normal paragraph is rendered as an emoji in Live Preview and Reading modes.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Integrate Skin Tone Support into Post-Processor",
        "description": "Update the post-processor rendering logic to apply the user's configured default skin tone to emojis that support it.",
        "details": "Inside the post-processor, after finding a shortcode and resolving it to an emoji object from `emoji-mart`, check if the emoji has skin tone variations. If so, retrieve the user's default skin tone from the plugin settings (`this.settings.skinTone`). Use the `getEmojiWithSkin` utility function provided by the `emoji-mart` data to get the correct character for the specified skin tone before rendering it.",
        "testStrategy": "Go to the plugin settings and set a default skin tone (e.g., 'medium-dark'). Create a note with a shortcode for an emoji that supports skin tones (e.g., `:wave:` or `:thumbsup:`). In Live Preview/Reading mode, verify that the rendered emoji displays with the selected skin tone. Change the setting and confirm the emoji updates on re-render.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Expose User Settings to the Markdown Post-Processor",
            "description": "Ensure the user's configured skin tone setting is accessible within the scope of the Markdown post-processor callback function. This is a prerequisite for applying the correct skin tone.",
            "dependencies": [],
            "details": "In the main plugin class where `registerMarkdownPostProcessor` is called, ensure the callback function has access to `this.settings`. Using an arrow function for the callback, like `(el, ctx) => { ... }`, will automatically preserve the `this` context of the class instance, making `this.settings.skinTone` available.",
            "status": "done",
            "testStrategy": "Add a `console.log(this.settings.skinTone)` inside the post-processor callback. Trigger the processor by typing an emoji shortcode in a note and verify that the configured skin tone value from the settings panel is correctly logged to the developer console."
          },
          {
            "id": 2,
            "title": "Identify Emojis Supporting Skin Tone Variations",
            "description": "After resolving a shortcode to an emoji object from `emoji-mart`, implement a check to determine if that specific emoji supports skin tone variations.",
            "dependencies": [
              "4.1"
            ],
            "details": "Inside the post-processor, once you have the `emoji` object, check for the existence and content of its skin tone data. A reliable check is to see if `emoji.skins` is an array and has a length greater than 1. This check will prevent attempts to apply skin tones to emojis that do not support them (e.g., animals, objects).",
            "status": "done",
            "testStrategy": "In the post-processor, log the result of the skin tone support check for different emojis. Test with `:wave:` (should be true) and `:cat:` (should be false) and verify the console output is correct."
          },
          {
            "id": 3,
            "title": "Import and Prepare the `getEmojiWithSkin` Utility",
            "description": "Import the `getEmojiWithSkin` utility function from the `@emoji-mart/data` package so it can be used to generate the correct emoji character.",
            "dependencies": [],
            "details": "At the top of the plugin file where the post-processor is defined, add an import statement: `import { getEmojiWithSkin } from '@emoji-mart/data'`. This makes the function available for use within the module.",
            "status": "done",
            "testStrategy": "Confirm that the application builds without errors after adding the import. No runtime test is needed for this step alone, as it will be tested in subsequent steps."
          },
          {
            "id": 4,
            "title": "Implement Conditional Logic to Select Emoji Character",
            "description": "Create the primary logic block that decides which emoji character to render. It should use the default character unless the emoji supports skin tones and a non-neutral skin tone is configured by the user.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3"
            ],
            "details": "Inside the post-processor, after resolving the emoji, create a variable `let finalEmojiChar = emoji.native;`. Then, use an `if` statement: `if (supportsSkinTones && this.settings.skinTone > 1) { ... }`. The `supportsSkinTones` boolean comes from subtask 4.2. The `skinTone > 1` check assumes '1' is the neutral/default value. Inside the `if` block, call `finalEmojiChar = getEmojiWithSkin(emoji, this.settings.skinTone);`.",
            "status": "done",
            "testStrategy": "Set a default skin tone in settings. Use `console.log` to output the `finalEmojiChar` variable. For `:wave:`, it should log the skinned version. For `:cat:`, it should log the default cat emoji. If the skin tone setting is neutral, `:wave:` should also log its default version."
          },
          {
            "id": 5,
            "title": "Update DOM Replacement to Render the Final Emoji Character",
            "description": "Modify the final step of the post-processor to use the character determined by the new skin tone logic when replacing the shortcode text in the DOM.",
            "dependencies": [
              "4.4"
            ],
            "details": "Locate the code that creates the new text node or span to replace the shortcode (e.g., `document.createTextNode(emoji.native)`). Change this to use the `finalEmojiChar` variable that was determined in the previous subtask. The line should now look like `document.createTextNode(finalEmojiChar)`.",
            "status": "done",
            "testStrategy": "Go to plugin settings and set a default skin tone (e.g., 'medium-dark', skin tone 4). Create a note with `:thumbsup:`. In Live Preview and Reading mode, verify the rendered emoji has the medium-dark skin tone. Change the setting to 'light' (skin tone 2) and refresh/re-render the view; verify the emoji updates to the light skin tone."
          }
        ]
      },
      {
        "id": 5,
        "title": "Fix Recents and Favorites Storage Logic for Shortcodes",
        "description": "Update the logic for tracking and storing recently used and favorited emojis to handle shortcodes (e.g., `:smile:`) instead of native emoji glyphs.",
        "details": "Locate the functions responsible for managing recent and favorite emojis. Modify the code that adds an emoji to the 'recents' list to store the emoji's `id` (e.g., 'smile') from the `emoji-mart` object. The persistence layer, whether `LocalStorage` or Obsidian's data API, should now store an array of these IDs. Apply the same logic to the favorites system.",
        "testStrategy": "Clear recent emoji history. Use the plugin to insert several emojis. Restart Obsidian. Open the emoji suggester and verify that the 'Recents' tab is correctly populated with the emojis you used. Test adding an emoji to favorites, restarting, and confirming it's still favorited.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor 'add to recents' function to use emoji ID",
            "description": "Locate the function responsible for adding a selected emoji to the 'recents' list. Modify this function to store the emoji's shortcode ID (e.g., 'smile') from the `emoji-mart` object instead of its native glyph.",
            "dependencies": [],
            "details": "Find the event handler for emoji selection in the picker. When an emoji is selected, it's passed to a function like `addToRecents(emoji)`. Change this function to extract `emoji.id` and push it to the in-memory array of recent emojis, rather than `emoji.native`.",
            "status": "done",
            "testStrategy": "Use a debugger or console logs to verify that after selecting an emoji, the in-memory array for recents contains the emoji's ID string, not the native character."
          },
          {
            "id": 2,
            "title": "Update persistence logic to save recent emoji IDs",
            "description": "Modify the function that saves the 'recents' list to persistent storage (e.g., `LocalStorage` or Obsidian's `saveData`). Ensure it now saves the array of emoji IDs generated by the updated 'add to recents' function.",
            "dependencies": [
              "5.1"
            ],
            "details": "Locate the code that calls `localStorage.setItem('emoji-recents', ...)` or a similar Obsidian API call. Ensure the data being passed is the array of string IDs. The key used for storage should remain the same to facilitate migration.",
            "status": "done",
            "testStrategy": "After selecting a few emojis, inspect the application's LocalStorage or the plugin's `data.json` file. Verify that the key for recent emojis now stores an array of strings (e.g., `[\"smile\", \"tada\", \"thumbsup\"]`)."
          },
          {
            "id": 3,
            "title": "Refactor 'toggle favorite' function to use emoji ID",
            "description": "Update the logic for adding and removing emojis from the 'favorites' list. The function should now operate on the emoji's shortcode ID instead of its native glyph.",
            "dependencies": [],
            "details": "Find the function that handles favoriting, likely `toggleFavorite(emoji)`. This function should check for the existence of `emoji.id` in the favorites array, and add or remove it accordingly. The in-memory favorites list should be an array of emoji IDs.",
            "status": "done",
            "testStrategy": "Use a debugger to step through the `toggleFavorite` function. Confirm that clicking the favorite icon adds the correct emoji ID to the in-memory favorites array and clicking it again removes it."
          },
          {
            "id": 4,
            "title": "Update persistence logic to save favorite emoji IDs",
            "description": "Modify the function that saves the 'favorites' list to persistent storage. This function must now save the array of favorite emoji IDs.",
            "dependencies": [
              "5.3"
            ],
            "details": "Similar to the recents persistence, find where the favorites array is saved to storage. Ensure it's writing the array of string IDs. This might be part of the same function that saves all plugin settings.",
            "status": "done",
            "testStrategy": "Add and remove a few emojis from favorites. Inspect the application's LocalStorage or the plugin's `data.json` file to confirm the favorites key stores an array of the correct emoji IDs."
          },
          {
            "id": 5,
            "title": "Implement a one-time data migration for existing user data",
            "description": "Create a migration routine that runs when the plugin loads. It should check if the stored 'recents' and 'favorites' data is in the old format (array of native glyphs). If so, it must convert this data to the new format (array of IDs) and save it to prevent data loss for existing users.",
            "dependencies": [
              "5.2",
              "5.4"
            ],
            "details": "In the plugin's `onload` method, when loading recents/favorites from storage, check the type of the first element in the array. If it's a multi-character string that is not a simple shortcode (i.e., it's a native emoji), assume it's old data. Iterate through the array, use the `emoji-mart` data index to find the corresponding ID for each native glyph, and create a new array of IDs. Overwrite the old stored data with this new array. This check should be performed every time data is loaded.",
            "status": "done",
            "testStrategy": "Manually set the storage key for recents to an array of native emojis (e.g., `[\"üòÄ\", \"üéâ\"]`). Reload Obsidian. Inspect the storage again. The key should now contain the migrated data (e.g., `[\"grinning\", \"tada\"]`). Repeat for favorites."
          }
        ]
      },
      {
        "id": 6,
        "title": "Update Recents/Favorites UI to Render from Shortcode IDs",
        "description": "Modify the UI for the 'Recents' and 'Favorites' sections in the emoji suggester to correctly render emoji glyphs from the newly stored shortcode IDs.",
        "details": "The UI rendering logic for the suggester's recents/favorites tabs currently expects a list of native emoji characters. This logic must be updated to handle a list of emoji IDs. For each ID, use the `emoji-mart` search index or data to find the corresponding emoji object and then render its native character in the UI.",
        "testStrategy": "After using several emojis, open the suggester. Navigate to the 'Recents' tab. Verify that it displays the correct emoji glyphs, not the text IDs. The visual appearance should be seamless to the user. Repeat this test for the 'Favorites' tab.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate and Analyze Current UI Rendering Logic for Recents/Favorites",
            "description": "Identify the specific UI components or functions responsible for rendering the emoji lists in both the 'Recents' and 'Favorites' tabs. Analyze how they currently receive and process the list of native emojis to understand the exact points for modification.",
            "dependencies": [],
            "details": "Search the codebase for keywords related to the emoji suggester, such as 'recents', 'favorites', 'EmojiSuggest'. Document the file paths and function/component names that handle the rendering loop for these lists. This is an investigation step to prepare for the code changes.",
            "status": "done",
            "testStrategy": "Manually inspect the identified code files and confirm they are responsible for rendering the UI by adding a temporary console.log() or a visual marker and observing the change in the running application."
          },
          {
            "id": 2,
            "title": "Implement a Centralized Emoji Lookup Utility",
            "description": "Create a reusable utility function that takes an emoji shortcode ID (e.g., 'smile') as input and returns the corresponding full emoji object from the `emoji-mart` dataset. This utility will be the core of the new rendering logic.",
            "dependencies": [],
            "details": "Create a new file, e.g., `emoji-utils.ts`. Implement a function like `getEmojiObjectById(id: string): EmojiObject | null`. This function should efficiently access the `emoji-mart` data index (e.g., `emojiIndex.search(id)` or direct lookup if possible). Ensure it gracefully handles cases where an ID is not found by returning null or undefined.",
            "status": "done",
            "testStrategy": "Write unit tests for the new utility function. Test with valid IDs (e.g., 'wave'), IDs with skin tones, and invalid/non-existent IDs to ensure it returns the correct emoji object or null as expected."
          },
          {
            "id": 3,
            "title": "Modify 'Recents' Tab to Render Emojis from IDs",
            "description": "Update the 'Recents' tab UI component identified in subtask 6.1. Modify its rendering loop to use the new lookup utility. The component will now map over the array of shortcode IDs, call the lookup utility for each ID, and render the `native` property of the resulting emoji object.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "In the 'Recents' component, change the data processing logic. Instead of directly iterating over the props array, use `props.recentIds.map(id => getEmojiObjectById(id))`. Filter out any null results. Then, map over the resulting array of emoji objects and pass the `native` character to the rendering element.",
            "status": "done",
            "testStrategy": "After implementation, clear recent emojis. Use several emojis to populate the recents list. Open the suggester and navigate to the 'Recents' tab. Verify that the correct emoji glyphs are displayed, not the text IDs."
          },
          {
            "id": 4,
            "title": "Modify 'Favorites' Tab to Render Emojis from IDs",
            "description": "Apply the same pattern from the 'Recents' tab update to the 'Favorites' tab UI component. Modify its rendering logic to use the same emoji lookup utility to convert favorite emoji IDs into renderable native emoji glyphs.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "This task mirrors the implementation of subtask 6.3 but targets the 'Favorites' component. Locate the component and update its data handling to iterate over an array of favorite IDs, use the `getEmojiObjectById` utility for conversion, and render the `native` property of each returned emoji object.",
            "status": "done",
            "testStrategy": "Add several emojis to favorites. Restart the application. Open the suggester and navigate to the 'Favorites' tab. Confirm that the correct emoji glyphs are displayed. Test removing a favorite and ensure the UI updates correctly."
          },
          {
            "id": 5,
            "title": "Refactor Shared Logic and Perform Final Integration Test",
            "description": "Review the updated code for both 'Recents' and 'Favorites' tabs. If there is significant duplicated logic, refactor it into a shared helper or component. Finally, perform a comprehensive end-to-end test of the entire feature.",
            "dependencies": [
              "6.3",
              "6.4"
            ],
            "details": "If both components use a similar `map -> lookup -> render` pattern, consider creating a generic `EmojiGridFromIds` component that accepts an array of IDs and renders the grid. This will improve maintainability. The final test should involve using the suggester normally, adding recents and favorites, and confirming both tabs work perfectly together.",
            "status": "done",
            "testStrategy": "Perform a full user workflow test: 1. Use several emojis. 2. Favorite some of them. 3. Restart Obsidian. 4. Open the suggester and check both 'Recents' and 'Favorites' tabs for correctness. 5. Un-favorite an emoji and verify the UI updates."
          }
        ]
      },
      {
        "id": 7,
        "title": "Remove Obsolete 'Insert Shortcode in Source Mode' Setting",
        "description": "Remove the settings UI toggle and associated code for 'inserting shortcodes in source mode,' as this behavior is now the default and only option.",
        "details": "Edit the plugin's settings tab definition file. Remove the `.addToggle()` component that creates the setting in the UI. In the settings data structure (e.g., `interface QuickEmojiSettings`), remove the corresponding boolean property. Finally, search the codebase for any usage of this setting and remove the conditional logic.",
        "testStrategy": "Open the plugin's settings tab in Obsidian. Verify that the option to 'insert shortcodes in source mode' is no longer visible. Confirm that its removal has not introduced any console errors or unexpected behavior.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove UI Toggle from Settings Tab",
            "description": "Locate the plugin's settings tab definition file and remove the UI component that allows users to toggle the 'insert shortcode in source mode' setting.",
            "dependencies": [],
            "details": "In the file responsible for building the settings UI (likely within the `display()` method of a `SettingTab` subclass), find the `.addToggle()` method call associated with the 'insert shortcode in source mode' setting. Delete this entire component definition block.",
            "status": "done",
            "testStrategy": "Open the plugin's settings panel in Obsidian. Verify that the toggle switch for 'insert shortcode in source mode' is no longer visible. Check the developer console for any errors that might arise from its removal."
          },
          {
            "id": 2,
            "title": "Remove Setting Property from Data Interface/Type",
            "description": "Delete the boolean property corresponding to the removed setting from the plugin's settings data structure, typically an interface or type definition.",
            "dependencies": [
              "7.1"
            ],
            "details": "Find the TypeScript interface or type definition for the plugin's settings (e.g., `interface QuickEmojiSettings`). Remove the property that was used to store the state of the removed toggle (e.g., `insertShortcodeInSourceMode: boolean;`).",
            "status": "done",
            "testStrategy": "After this change, run a TypeScript check or build process. It should fail in any files that still reference this property, which helps identify where further changes are needed."
          },
          {
            "id": 3,
            "title": "Update Default Settings Object",
            "description": "Remove the obsolete setting's property from the `DEFAULT_SETTINGS` constant object to ensure new installations and settings resets do not include the legacy key.",
            "dependencies": [
              "7.2"
            ],
            "details": "Locate the constant object that defines the default values for all settings (e.g., `const DEFAULT_SETTINGS: QuickEmojiSettings = { ... };`). Delete the key-value pair for the 'insert shortcode in source mode' setting from this object. This ensures consistency with the updated settings interface.",
            "status": "done",
            "testStrategy": "Temporarily move your `data.json` settings file to force the plugin to load with default settings. Verify that the plugin loads without errors and that the obsolete setting key is not present in the newly created `data.json`."
          },
          {
            "id": 4,
            "title": "Purge Conditional Logic Relying on the Obsolete Setting",
            "description": "Search the entire codebase for any usage of the removed setting property and eliminate the conditional logic that depended on it, making the 'insert shortcode' behavior unconditional.",
            "dependencies": [
              "7.3"
            ],
            "details": "Perform a project-wide search for the setting's property name (e.g., `this.settings.insertShortcodeInSourceMode`). Remove any `if/else` statements or ternary operators that reference this property. The code should be refactored to only execute the logic that was previously in the `if (true)` block, which is to always insert the shortcode.",
            "status": "done",
            "testStrategy": "Trigger the emoji suggester in both Source Mode and Live Preview. In both modes, selecting an emoji must result in its shortcode (e.g., `:smile:`) being inserted into the editor. This confirms the old conditional logic is gone."
          },
          {
            "id": 5,
            "title": "Final Code Cleanup and End-to-End Verification",
            "description": "Review all modified files for any remaining code artifacts (e.g., unused imports, comments) related to the removed feature and perform a final verification of the plugin's behavior.",
            "dependencies": [
              "7.4"
            ],
            "details": "Scan the files modified in the previous subtasks. Remove any `import` statements, comments, or variable declarations that are now unused as a result of the feature removal. Re-run the full test suite if one exists.",
            "status": "done",
            "testStrategy": "Perform the full test described in the parent task: 1. Open settings and confirm the toggle is gone. 2. Check the developer console for errors during startup and use. 3. Confirm that inserting emojis always produces a shortcode in all editor modes. 4. Confirm that the post-processor (Task 2) correctly renders these shortcodes into glyphs."
          }
        ]
      },
      {
        "id": 8,
        "title": "Comprehensive End-to-End Testing and Validation",
        "description": "Conduct comprehensive end-to-end testing of the entire shortcode-first user flow, covering all acceptance criteria and edge cases to ensure a bug-free release.",
        "details": "Create and execute a test plan covering all functionality on desktop and mobile. Key scenarios include: 1. Insertion and rendering in all editor modes. 2. Boundary checks (code, math, inline code). 3. Skin tone application. 4. Recents/Favorites persistence and UI rendering. 5. Performance on large files with many shortcodes. 6. Run `eslint` or other configured linters to ensure code quality.",
        "testStrategy": "Systematically execute the test plan, documenting results. Verify that all acceptance criteria from the PRD are met. Monitor the developer console for any runtime errors during testing. The plugin should feel stable and performant.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Update User Documentation and README",
        "description": "Update the plugin's README.md and other user-facing documentation to explain the new shortcode-first behavior and its benefits.",
        "details": "Edit the `README.md` file. Add a section explaining that the plugin now exclusively uses shortcodes (`:shortcode:`) for storage to improve cross-platform compatibility. Explain that these are automatically rendered as glyphs in Live Preview and Reading modes. Update any screenshots or GIFs to reflect the new user flow.",
        "testStrategy": "Review the updated `README.md` from the perspective of a new user. Ensure the explanation is clear, concise, and accurately describes the plugin's behavior. Verify that all examples and visuals are up-to-date.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Draft Explanatory Text for Shortcode Behavior",
            "description": "Write the new documentation content that explains the shift to a shortcode-first storage model. This text will be the source material for the README update.",
            "dependencies": [],
            "details": "In a separate text file, draft a clear and concise explanation covering these points:\n1. The plugin now stores emojis as shortcodes (e.g., `:smile:`) instead of Unicode characters in the Markdown source.\n2. The primary benefit is improved cross-platform compatibility and data portability.\n3. Explain that shortcodes are automatically rendered as emoji glyphs in Obsidian's Live Preview and Reading modes, so the user experience remains seamless.\n4. Mention that this prevents issues with file syncing and editing notes on different operating systems.",
            "status": "done",
            "testStrategy": "Have a team member read the drafted text to ensure it is understandable for a non-technical user. Verify all key points are covered."
          },
          {
            "id": 2,
            "title": "Update README.md with New Shortcode Explanation",
            "description": "Integrate the drafted text from the previous subtask into the main `README.md` file. This involves creating a new section or updating existing ones to reflect the new behavior.",
            "dependencies": [
              "9.1"
            ],
            "details": "Edit the `README.md` file. Create a new prominent section, perhaps titled 'How It Works: Shortcode Storage', or update the main 'Features' section. Insert the drafted text explaining the shortcode-first approach. Review existing sections and remove any outdated information that refers to storing native emoji glyphs.",
            "status": "done",
            "testStrategy": "Review the raw `README.md` file to confirm the new text has been added correctly and outdated information has been removed. Check the formatting in a Markdown previewer."
          },
          {
            "id": 3,
            "title": "Capture New Screenshots and GIFs",
            "description": "Create new visual assets (screenshots and/or animated GIFs) that accurately demonstrate the current user flow, showing shortcodes in the editor and rendered glyphs in preview modes.",
            "dependencies": [],
            "details": "Using the updated plugin, perform the following actions and capture them:\n1.  **Screenshot 1:** Show a note in Source Mode or Live Preview's source view with visible shortcodes like `:tada:` and `:rocket:`.\n2.  **Screenshot 2 / GIF:** Show the same note in Live Preview or Reading Mode where the shortcodes are rendered as their corresponding emoji glyphs (üéâ and üöÄ).\n3.  **GIF:** Capture the process of opening the emoji suggester, selecting an emoji, and it being inserted as a shortcode into the editor.\nEnsure the visuals are clean, focused, and saved in an optimized format (e.g., PNG for screenshots, compressed GIF/MP4 for animations).",
            "status": "done",
            "testStrategy": "View the captured images and GIFs to ensure they are clear, high-quality, and accurately represent the plugin's new functionality."
          },
          {
            "id": 4,
            "title": "Integrate New Visuals into README.md",
            "description": "Embed the newly created screenshots and GIFs into the `README.md` file, replacing any outdated visuals.",
            "dependencies": [
              "9.2",
              "9.3"
            ],
            "details": "Edit the `README.md` file. Locate the sections where visuals are displayed (e.g., 'Usage', 'Features'). Remove any old screenshots or GIFs that show the previous behavior. Add the new visuals captured in the previous subtask using appropriate Markdown image syntax. Ensure the images are placed logically alongside the text that describes them.",
            "status": "done",
            "testStrategy": "View the `README.md` on a platform like GitHub or in a local Markdown previewer to confirm that all new images and GIFs render correctly and old ones have been removed."
          },
          {
            "id": 5,
            "title": "Final Review and Proofread of All Documentation",
            "description": "Conduct a comprehensive review of the entire updated `README.md` and any other user-facing documentation to ensure clarity, consistency, and accuracy.",
            "dependencies": [
              "9.4"
            ],
            "details": "Read through the entire `README.md` from the perspective of a brand new user. Check for:\n- Typographical and grammatical errors.\n- Consistency in terminology (e.g., always using 'shortcode').\n- Clarity of the explanation for the new feature.\n- Broken links or images.\n- Overall flow and readability.\nMake any necessary final edits to polish the documentation.",
            "status": "done",
            "testStrategy": "Ask someone unfamiliar with the recent changes to read the documentation and confirm they understand how the plugin works. Verify that all instructions are correct and easy to follow."
          }
        ]
      },
      {
        "id": 10,
        "title": "Perform Plugin Submission Compliance Cleanup",
        "description": "Perform final cleanup to meet the compliance requirements for the official Obsidian plugin store, including naming conventions, logging, and settings UI standards.",
        "details": "1. **Naming**: In `manifest.json` and the settings tab header, ensure the plugin is named 'Quick Emoji', not 'Obsidian Quick Emoji'. 2. **Logging**: Search the entire codebase for `console.log()` statements and remove them. 3. **Settings UI**: Review the settings tab to ensure all descriptions use sentence case and headings are correctly implemented. 4. **Copyright**: Update copyright year and information as needed.",
        "testStrategy": "Manually inspect the `manifest.json` file and the rendered settings tab in Obsidian. Perform a global search for `console.log`. Review the code against the official Obsidian plugin development guidelines to ensure all standards are met.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update manifest.json with Compliant Plugin Name",
            "description": "Modify the plugin's manifest file to use the official name 'Quick Emoji' instead of 'Obsidian Quick Emoji' to comply with Obsidian's naming conventions for store submission.",
            "dependencies": [],
            "details": "Open the `manifest.json` file in the root of the project. Locate the `name` key and change its value from 'Obsidian Quick Emoji' to 'Quick Emoji'. Verify that other metadata like `id` and `author` are correct and do not contain the word 'Obsidian'.",
            "status": "done",
            "testStrategy": "After making the change, load the plugin in Obsidian's development mode. Go to the 'Community Plugins' list and verify that the plugin is listed as 'Quick Emoji'."
          },
          {
            "id": 2,
            "title": "Remove All `console.log` Statements from Codebase",
            "description": "Perform a global search across all source files and remove any remaining `console.log()` statements used for debugging, as these are not permitted in plugins submitted to the official store.",
            "dependencies": [],
            "details": "Use your IDE's global search feature or a command-line tool like `grep` to find all occurrences of `console.log(`. Review each occurrence and remove the entire line. Be careful not to remove other console methods like `console.error` if they are used for legitimate user-facing error reporting.",
            "status": "done",
            "testStrategy": "Perform a final global search for `console.log` after the cleanup to ensure no instances remain in the codebase. Run the plugin and check the developer console to confirm no new logs are being printed during normal operation."
          },
          {
            "id": 3,
            "title": "Standardize Settings Tab UI Text and Headings",
            "description": "Review and update the settings tab UI to meet submission standards. This includes setting the correct header name, ensuring all setting descriptions use sentence case, and verifying heading structures are correct.",
            "dependencies": [],
            "details": "In the file that implements the settings tab (e.g., `settings.ts`), find the code that adds the main header and ensure it displays 'Quick Emoji'. Then, review every `.setDesc()` call for each setting. Rewrite the descriptions to use proper sentence case (starting with a capital letter and ending with a period). Check that any section headings are implemented using `.addHeading()`.",
            "status": "done",
            "testStrategy": "Open the plugin's settings tab in Obsidian. Visually inspect the main header. Read through every setting's name and description to confirm the text formatting is correct and consistent."
          },
          {
            "id": 4,
            "title": "Update Copyright Year and Information",
            "description": "Update the copyright year in the project's license file and any other relevant metadata files to reflect the current year.",
            "dependencies": [],
            "details": "Open the `LICENSE` file and update the copyright year to the current year. Also, check `package.json` and any source file headers that may contain copyright information and update them as necessary.",
            "status": "done",
            "testStrategy": "Manually inspect the `LICENSE` file and `package.json` to confirm the copyright year has been updated correctly."
          },
          {
            "id": 5,
            "title": "Final Compliance Review Against Official Guidelines",
            "description": "Perform a final check of the entire plugin against the official Obsidian plugin submission guidelines to ensure all requirements have been met and nothing was overlooked in the previous cleanup steps.",
            "dependencies": [
              "10.1",
              "10.2",
              "10.3",
              "10.4"
            ],
            "details": "Read through the latest version of the Obsidian sample plugin repository's submission guidelines. Create a mental checklist and verify each point for the 'Quick Emoji' plugin. Pay special attention to data storage locations (using `.obsidian/plugins/your-plugin-id/data.json`), icon requirements, and README content.",
            "status": "done",
            "testStrategy": "Simulate the submission process by reviewing the plugin as if you were a member of the Obsidian review team. Cross-reference each feature and file against the official submission checklist to ensure 100% compliance."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-13T15:20:10.808Z",
      "updated": "2025-08-13T17:26:35.295Z",
      "description": "Tasks for master context"
    }
  },
  "emoji-insertion-format": {
    "tasks": [
      {
        "id": 1,
        "title": "Update Settings Schema and Default Configuration",
        "description": "Modify the QuickEmojiSettings interface to include the new insertionFormat property and update the DEFAULT_SETTINGS object to establish 'unicode' as the default value for backward compatibility.",
        "details": "In the relevant TypeScript file (e.g., `src/main.ts` or a dedicated types file), update the `QuickEmojiSettings` interface to add `insertionFormat: 'unicode' | 'shortcode'`. Then, modify the `DEFAULT_SETTINGS` constant to include `insertionFormat: 'unicode'`. This ensures that existing users who upgrade will default to the original Unicode insertion behavior, preventing unexpected changes to their workflow.\n<info added on 2025-08-14T11:38:40.567Z>\nThe QuickEmojiSettings interface was updated to include the `insertionFormat` property, using a new `InsertionFormat` type alias ('unicode' | 'shortcode') for better code organization. The DEFAULT_SETTINGS object was updated to include `insertionFormat: 'unicode'` for backward compatibility. The changes passed TypeScript checks without any errors.\n</info added on 2025-08-14T11:38:40.567Z>",
        "testStrategy": "Perform a static type check using the TypeScript compiler (e.g., `tsc`) to ensure no type errors are introduced. Manually review the git diff to confirm the interface and default object are correctly updated as specified.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Ensure Setting Persistence and Migration",
        "description": "Implement the necessary logic to correctly load the new `insertionFormat` setting for all users and persist their choice across Obsidian sessions.",
        "details": "In `src/main.ts`, review the `loadSettings()` method. The standard implementation `this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());` should suffice. This pattern correctly handles migration for existing users by merging their saved settings (which lack the new key) with the `DEFAULT_SETTINGS` object, thereby applying the 'unicode' default. The `saveSettings()` method should already handle saving the entire settings object, which will now include the new property.\n<info added on 2025-08-14T11:53:43.094Z>\nVerification completed. The existing `loadSettings()` method, which uses `Object.assign({}, DEFAULT_SETTINGS, await this.loadData())`, is confirmed to be correct for migration purposes. It properly provides the `insertionFormat: 'unicode'` default for both new and existing users. The `saveSettings()` method also works as expected, saving the complete settings object including the new property. No additional code is needed. The project builds successfully.\n</info added on 2025-08-14T11:53:43.094Z>",
        "testStrategy": "1. Test with a fresh install (no settings file) and verify the format defaults to 'unicode'. 2. Test with a pre-existing settings file (without the `insertionFormat` key) and verify the setting defaults to 'unicode' on plugin load. 3. Change the setting, reload the plugin, and confirm the chosen setting is correctly loaded.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add Insertion Format Dropdown to Settings UI",
        "description": "Add a new dropdown menu to the plugin's settings tab, allowing users to select their preferred emoji insertion format.",
        "details": "In `src/ui/settings-tab.ts`, within the `display()` method, use the Obsidian API's `Setting` class. Position the new setting logically, for instance, after the skin tone setting. Use `new Setting(containerEl).setName('Insertion format').setDesc('Choose how emojis are inserted...').addDropdown(dropdown => { dropdown.addOption('unicode', 'Unicode emoji').addOption('shortcode', 'Shortcode').setValue(this.plugin.settings.insertionFormat).onChange(async (value) => { this.plugin.settings.insertionFormat = value; await this.plugin.saveSettings(); }); });` Ensure the descriptive text from the PRD is included.\n<info added on 2025-08-14T12:08:14.070Z>\nTask completed successfully. The insertion format dropdown was added to the settings UI, positioned after the skin tone setting. The dropdown includes 'unicode' (Unicode emoji) and 'shortcode' (Shortcode) options. A clear descriptive text explains the difference between the formats, with examples like (üôÇ) for Unicode and (:smile:) for shortcode, and clarifies visibility differences in all views versus Reading Mode. The implementation uses proper TypeScript typing with an `InsertionFormat` type cast. The `onChange` handler saves the setting immediately, and the project builds successfully.\n</info added on 2025-08-14T12:08:14.070Z>",
        "testStrategy": "Open the plugin settings in Obsidian. Verify the 'Insertion format' dropdown appears with the correct label, descriptive text, and options. Change the selection and verify it's saved by closing and reopening the settings tab. Check that the value is correctly updated in the `data.json` file.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Centralized Emoji Insertion Helper",
        "description": "Create a centralized helper function to handle the actual insertion of emojis into the editor, which will simplify logic and prevent code duplication.",
        "details": "In a utility file (e.g., `src/util.ts`), create an exported function like `export function insertEmoji(editor: Editor, emoji: any, format: 'unicode' | 'shortcode')`. The `emoji` parameter will be the object from the emoji library (e.g., emoji-mart), which typically has properties like `emoji.native` for the Unicode character and `emoji.id` for the shortcode name. The function will determine the string to insert: `const textToInsert = format === 'unicode' ? emoji.native : \":${emoji.id}:\";`. Finally, it will use `editor.replaceSelection(textToInsert);` to place the text in the note.\n<info added on 2025-08-14T12:21:20.073Z>\nTask completed. The centralized emoji insertion helper was created in `src/utils/index.ts`.\n\nImplementation Details:\n- The `insertEmoji()` function handles both unicode and shortcode formats.\n- A `sanitizeShortcode()` helper function was also created, moved from the emoji-suggester.\n- The function supports both suggester context (replaceRange) and simple insertion (replaceSelection).\n- Unicode format uses `getEmojiWithSkin()` for proper skin tone support.\n- Shortcode format uses proper sanitization and fallback logic.\n- The function signature was updated to include parameters for skinTone and an optional context for range replacement.\n\nFinal Function Signature:\n`export function insertEmoji(editor: Editor, emoji: Emoji, format: InsertionFormat, skinTone: SkinSetting, context?: { start: EditorPosition; end: EditorPosition }): void`\n</info added on 2025-08-14T12:21:20.073Z>",
        "testStrategy": "If the project has a testing framework, write unit tests for this helper function. Pass it a mock editor object and different format values ('unicode', 'shortcode') and assert that the `replaceSelection` method is called with the expected string ('üôÇ' vs. ':smile:').",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Integrate Insertion Helper into Emoji Suggester",
        "description": "Update the Emoji Suggester component to use the new centralized insertion helper, ensuring it respects the user's format choice.",
        "details": "In `src/ui/emoji-suggester.ts`, locate the `selectSuggestion(value: any, evt: MouseEvent | KeyboardEvent)` method. Replace the existing insertion logic with a call to the new helper function: `insertEmoji(this.editor, value.emoji, this.plugin.settings.insertionFormat);`. Ensure any logic for handling skin tones is applied to the `value.emoji` object *before* it is passed to the helper.",
        "testStrategy": "1. Set format to 'Unicode' in settings. Trigger the suggester (e.g., type `:smile`) and select an emoji. Verify the native Unicode character is inserted. 2. Switch format to 'Shortcode'. Repeat the process and verify the text shortcode is inserted. 3. Test with an emoji that supports skin tones to ensure they are applied correctly in both modes.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Update Recent Emojis to Use Insertion Helper",
        "description": "Modify the click handlers for the 'Recent Emojis' list in the settings tab to use the centralized insertion helper for consistent behavior.",
        "details": "In `src/ui/settings-tab.ts`, find the code that generates the list of recent emojis and attaches click handlers. In the `onClick` callback for each emoji element, call the centralized `insertEmoji()` helper. You will need to get a reference to the active editor, which can be done via `this.app.workspace.activeEditor?.editor`, and pass it along with the emoji object and the setting `this.plugin.settings.insertionFormat`.\n<info added on 2025-08-14T12:30:49.780Z>\nTask completed successfully. Updated recent emoji click handlers to use centralized insertion helper.\n\nImplementation Details:\n- Added `insertEmoji` import to settings-tab.ts\n- Updated click handler in `renderRecentEmojis()` method\n- Replaced hardcoded shortcode insertion with centralized helper call\n- Now respects user's insertion format preference and skin tone settings\n- Uses the full emoji object (already available in scope) instead of just emojiId\n\nKey Changes:\n// OLD: Hardcoded shortcode insertion\nemojiEl.addEventListener('click', () => {\n    const editor = getActiveEditor(this.app)\n    if (editor) {\n        editor.replaceSelection(`:${emojiId}:`)\n    }\n})\n\n// NEW: Centralized helper respecting user preferences\nemojiEl.addEventListener('click', () => {\n    const editor = getActiveEditor(this.app)\n    if (editor) {\n        insertEmoji(\n            editor,\n            emoji,\n            this.plugin.settings.insertionFormat,\n            this.plugin.settings.skin\n        )\n    }\n})\n\nBuild Verification: Project builds successfully\nIntegration Quality: Consistent behavior with main suggester functionality\n</info added on 2025-08-14T12:30:49.780Z>",
        "testStrategy": "1. Set format to 'Unicode'. Open settings, click a recent emoji, and verify the native character is inserted into the currently active note. 2. Switch format to 'Shortcode'. Repeat the test and verify the shortcode is inserted instead.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Update Favorite Emojis to Use Insertion Helper",
        "description": "Modify the click handlers for the 'Favorite Emojis' list in the settings tab to use the centralized insertion helper.",
        "details": "Similar to the 'Recent Emojis' task, locate the logic for 'Favorite Emojis' in `src/ui/settings-tab.ts`. Update the `onClick` handler to call the `insertEmoji()` helper function, passing the active editor instance, the favorite emoji object, and the current `insertionFormat` setting from `this.plugin.settings`.\n<info added on 2025-08-14T12:35:49.064Z>\nTask completed successfully. The favorite emoji logic in the `renderFavoriteEmojis()` method was updated. The click handler now uses the centralized `insertEmoji` helper instead of hardcoded shortcode insertion. This change ensures that inserting a favorite emoji respects the user's configured insertion format and skin tone settings by using the full emoji object available in scope.\n</info added on 2025-08-14T12:35:49.064Z>",
        "testStrategy": "1. Add an emoji to favorites. 2. Set format to 'Unicode'. In settings, click the favorite emoji and verify the native character is inserted into the active note. 3. Switch format to 'Shortcode'. Repeat the test and verify the shortcode is inserted.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Update Plugin Documentation",
        "description": "Update the plugin's README.md file and any other user-facing documentation to describe the new 'Insertion Format' setting, its options, and behavior.",
        "details": "Edit the `README.md` file to include a new section under 'Settings' or 'Features'. Clearly explain the 'Insertion Format' option, detailing the difference between 'Unicode emoji' and 'Shortcode' as described in the PRD. Including a screenshot of the new setting in the UI is highly recommended to improve clarity.\n<info added on 2025-08-14T12:39:23.447Z>\nThe plugin documentation has been updated to reflect the new insertion format feature. Key changes include: updating the 'Features' section to highlight 'Flexible Insertion Format'; revising the 'How It Works' and 'Usage' sections to explain both Unicode and Shortcode options; and adding a detailed comparison of the two formats with pros and cons. The 'Settings' section now clearly describes the 'Insertion Format' option. The documentation maintains clear, user-friendly language with concrete examples for both formats and explains viewing differences across Obsidian modes. All markdown linting issues have been resolved.\n</info added on 2025-08-14T12:39:23.447Z>",
        "testStrategy": "Review the rendered `README.md` on GitHub or locally. Check for clarity, accuracy, and completeness. Ensure the description matches the final implementation and that any screenshots are up-to-date.",
        "priority": "low",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-14T11:29:41.091Z",
      "updated": "2025-08-14T12:39:29.066Z",
      "description": "Tasks for emoji-insertion-format context"
    }
  }
}